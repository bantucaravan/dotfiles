[user]
	name = Noah Chasek-Macfoy
	email = bantucaravan@gmail.com


[core]
	# editor = code --wait
    editor = cursor --wait
[diff]
    tool = cursor
[difftool "cursor"]
    cmd = cursor --wait --diff $LOCAL $REMOTE
[difftool "code"]
    cmd = code --wait --diff $LOCAL $REMOTE
[difftool]
    # don't ask permission to open difftool app
	prompt = false
[merge]
    tool = cursor
[mergetool "cursor"]
    cmd = cursor --wait --merge $REMOTE $LOCAL $BASE $MERGED
[mergetool "code"]
    cmd = code --wait --merge $REMOTE $LOCAL $BASE $MERGED


[alias]
    # USAGE: git id-auto-merge  <incoming> <destination>
    # DOC: file diffs from destination to incoming, but only for files that were modified from merge base to incoming.  
    # NB: this is different, more inclusive, than files that were modified in both dest and incom. Modified in \
    # both dest and incom are sites of potential merge conflict, but exclude modified in only incoming thus \
    # overwriting destination in an auto-merge. 
    # NOTE: quotes provide handling for branch names with spaces or special characters.
    # NOTE: files modified in incoming, deleted in destination are shown as added.
    # BUG: for file deleted in destination it (a) does not show if not modified in incoming or (b) labels added if modified in incoming. (this case will raise a merge conflict bc the same lines were affected in both) Potential Solution: add a separate diff only for files deleted in the destination.
    # BUG: for file renamed in destination it (a) does not show if not modified in incoming or (b) labels added if modified in incoming. (Q: will the raise a merge conflict?) Potential Solution: run diff â€”name-status, but \
    # loop thru text match for renamed files from merge-base OR a separate diff only for filed renamed in destination.
    # BUG: files renamed in incoming (both modified in destination and not) are shown as added only not renamed
    # BUG: does not show files with spaces!
    # TODO: print MERGE_BASE commit hash
    diff-incoming = "!f() { git diff --name-status \"$2\" \"$1\" -- $(git diff --name-only $(git merge-base \"$2\" \"$1\") \"$1\"); }; f"

    diffstatus = "!bash ~/dotfiles/git-diffstatus.sh"
  
    # add --pretty to negate the effect of --oneline and get full messages
    # graph log with all branches - no date and author
    # graphlog = log --graph --all --oneline

    # graph log with all branches - with date and author
    graphlog = log --all --graph --pretty=format:'%Cgreen%ad%Creset %C(auto)%h%d %s %C(bold black)<%aN>%Creset' --date=format-local:'%Y-%m-%d %H:%M (%a)'

    manual-premerge = "!bash ~/dotfiles/git-manual-premerge.sh"

    # Show diff btw <commitref> and previous commit for <file> in default difftool editor
    # `git showtool <commitref> <path>`
    # <path> MUST be relative to .git/ parent dir
    # merge commit behavior is somewhat complex
    # inspo: https://stackoverflow.com/questions/17558221/how-can-i-view-the-output-of-git-show-in-a-diff-viewer-like-meld-kdiff3-etc 
    showtool = "!f() { git difftool $1~1 $1 -- \"$2\"; }; f"
    ##  ALT: with path relative to CWD
    # showtool = "!f() { \
    # local commit=\"$1\"; \
    # local file=\"$2\"; \
    # local prefix=$(git rev-parse --show-prefix); \
    # git difftool \"$commit~1\" \"$commit\" -- \"${prefix}${file}\"; \
    # }; f"
	
# [filter "lfs"]
# 	clean = git-lfs clean -- %f
# 	smudge = git-lfs smudge -- %f
# 	process = git-lfs filter-process
# 	required = true

[mergetool]
	keepBackup = false

[push]
    # automatically does push --set-upstream when no remote tracking branch exists
	autoSetupRemote = true

[fetch]
    # automatically add --prune to git fetch
	prune = true
